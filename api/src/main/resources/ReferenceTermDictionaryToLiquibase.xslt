<?xml version="1.0" encoding="utf-8"?>
<!-- Stylesheet that processes an Excel processable XML file into the liquibase changelog XML format -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:rd="http://ohie.org/openshr/data"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
                xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"
                exclude-result-prefixes="rd"
>
  <xsl:output method="xml" indent="yes"/>

  <xsl:template match="/rd:referenceTermDictionary">
    <databaseChangeLog xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">
	  <include file="liquibase.orders.xml"/>
	  <include file="liquibase.concepts.xml"/>
      <xsl:comment>
        <![CDATA[
	        This change file has been automatically generated from a source file containing reference terms
	        and their mapping to OpenMRS concepts. 

	        !DO NOT EDIT THIS FILE!
	
	        This file is automatically created upon building the SHR CDA Content Handler
	        ]]>
      </xsl:comment>
      <!--<property name="now" value="now()"/>-->

      <!-- Create concept sources -->
      <xsl:for-each select="//rd:referenceTerm[rd:codeSystem/text() and not(rd:codeSystem/text()=preceding::rd:referenceTerm/rd:codeSystem/text())]">
        <xsl:sort select="rd:codeSystemName"/>
        <changeSet  dbms="mysql" id="shr-cdahandler-{position() }" author="justin" runInTransaction="true">
          <preConditions onError="HALT" onFail="MARK_RAN">
            <and>
              <tableExists tableName="concept_reference_source"/>
              <sqlCheck expectedResult="0">
                select count(name) from concept_reference_source where name='<xsl:value-of select="rd:codeSystemName"/>'
              </sqlCheck>
            </and>
          </preConditions>
          <insert tableName="concept_reference_source">
            <column name="name" value="{rd:codeSystemName}"/>
            <column name="description" value="{rd:codeSystemName} Codes"/>
            <column name="creator" valueNumeric="1"/>
            <column name="date_created" valueComputed="now()"/>
            <column name="uuid" valueComputed="uuid()"/>
            <column name="retired" valueNumeric="0"/>
            <column name="hl7_code" value="{rd:codeSystem}"/>
          </insert>
        </changeSet>
      </xsl:for-each>

      <!-- Create concept classes -->
      <xsl:for-each select="//rd:referenceTerm[rd:classification/text() and not(rd:classification/text()=preceding::rd:referenceTerm/rd:classification/text())]">
        <xsl:sort select="rd:classification"/>
        <changeSet  dbms="mysql" id="shr-cdahandler-{position() + 70}" author="justin" runInTransaction="true">
          <preConditions onError="HALT" onFail="MARK_RAN">
            <and>
              <tableExists tableName="concept_class"/>
              <sqlCheck expectedResult="0">
                select count(name) from concept_class where name='<xsl:value-of select="rd:classification"/>'
              </sqlCheck>
            </and>
          </preConditions>
          <insert tableName="concept_class">
            <column name="name" value="{rd:classification}"/>
            <column name="description" value="{rd:classification} Codes"/>
            <column name="creator" valueNumeric="1"/>
            <column name="date_created" valueComputed="now()"/>
            <column name="uuid" valueComputed="uuid()"/>
            <column name="retired" valueNumeric="0"/>
          </insert>
        </changeSet>
      </xsl:for-each>
      <xsl:apply-templates />

    </databaseChangeLog>

  </xsl:template>

  <!-- Match reference term -->
  <xsl:template match="rd:referenceTerm">
    <!-- Create reference term if not exists -->
    <xsl:variable name="taskId" select="rd:id * 100"/>

    <xsl:if test="rd:codeSystem/text()">
      <changeSet  dbms="mysql" id="shr-cdahandler-{$taskId}" author="justin" runInTransaction="true">
        <preConditions onError="HALT" onFail="MARK_RAN">
          <and>
            <tableExists tableName="concept_reference_term"/>
            <sqlCheck expectedResult="0">
              select count(code) from concept_reference_term inner join concept_reference_source on (concept_reference_term.concept_source_id = concept_reference_source.concept_source_id) where
              code = '<xsl:value-of select="rd:code"/>' and concept_reference_source.name = '<xsl:value-of select="rd:codeSystemName"/>';
            </sqlCheck>
          </and>
        </preConditions>
        <comment>
          Adding <xsl:value-of select="rd:code"/> to reference terms
        </comment>
        <insert tableName="concept_reference_term">
          <column name="concept_reference_term_id" autoIncrement="true"/>
          <column name="concept_source_id" valueComputed="(select concept_source_id from concept_reference_source where name = '{rd:codeSystemName}')"/>
          <column name="name" value="{rd:description}"/>
          <column name="code" value="{rd:code}"/>
          <column name="description" value="{rd:description}"/>
          <column name="uuid" valueComputed="uuid()"/>
          <column name="creator" valueNumeric="1"/>
          <column name="date_created" valueComputed="now()"/>
        </insert>
      </changeSet>
    </xsl:if>

    <!-- create name variable -->
    <xsl:variable name="conceptName">
      <xsl:choose>
        <xsl:when test="rd:mapping/rd:concept/rd:name/text()">
          <xsl:value-of select="rd:mapping/rd:concept/rd:name/text()"/>
        </xsl:when>
        <xsl:when test="rd:conceptType = 'Numeric' and rd:units/text()">
          <xsl:value-of select="concat(rd:description, ' (', rd:units, ')')"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="rd:description"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="id" select="rd:id"/>
    <xsl:variable name="isSet" select="//rd:setOf[contains(text(),$id)]"/>

    <!-- Create concept if not exists or not specified -->
    <xsl:choose>
      <xsl:when test="not(rd:mapping/rd:concept/rd:cielId/text())">
        <changeSet  dbms="mysql" author="justin" id="shr-cdahandler-{$taskId + 1}" runInTransaction="true">
          <preConditions onError="HALT" onFail="MARK_RAN">
            <and>
              <tableExists tableName="concept_name"/>
              <tableExists tableName="concept"/>
              <!-- Create a concept -->
              <sqlCheck expectedResult="0">
                select count(concept_id) from concept_name where name='<xsl:value-of select="$conceptName"/>' and locale='en'
              </sqlCheck>
              <sqlCheck expectedResult="1">
                select count(concept_datatype_id) from concept_datatype where name='<xsl:value-of select="rd:conceptType"/>'
              </sqlCheck>
            </and>
          </preConditions>
          <comment>
            Adding <xsl:value-of select="$conceptName"/> to concepts and adding mapping to reference term
          </comment>
          <insert tableName="concept">
            <column name="concept_id" autoIncrement="true"/>
            <column name="short_name" value="{rd:code}"/>
            <column name="description" value="{$conceptName}"/>
            <column name="uuid" value="{rd:uuid}"/>
            <column name="datatype_id" valueComputed="(select concept_datatype_id from concept_datatype where name='{rd:conceptType}')"/>
            <xsl:choose>
              <!-- SET -->
              <xsl:when test="$isSet">
                <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='ConvSet')"/>
              </xsl:when>
              <xsl:when test="rd:classification/text()">
                <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='{rd:classification}')"/>
              </xsl:when>
              <xsl:otherwise>
                <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='Misc')"/>
              </xsl:otherwise>
            </xsl:choose>
            <column name="is_set" valueBoolean="{count($isSet) > 0}"/>
            <column name="creator" valueNumeric="1"/>
            <column name="date_created" valueComputed="now()"/>
          </insert>
          <insert tableName="concept_name">
            <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{rd:uuid}' )"/>
            <column name="name" value="{$conceptName}"/>
            <column name="locale" value="en"/>
            <column name="creator" valueNumeric="1"/>
            <column name="date_created" valueComputed="now()"/>
            <column name="uuid" valueComputed="uuid()"/>
            <column name="concept_name_id" autoIncrement="true"/>
            <column name="concept_name_type" value="FULLY_SPECIFIED"/>
            <column name="locale_preferred" valueBoolean="1"/>
          </insert>
          <xsl:choose>
            <xsl:when test="rd:conceptType = 'Numeric'">
              <insert tableName="concept_numeric">
                <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{rd:uuid}' )"/>
                <column name="units" value="{rd:units}"/>
              </insert>
            </xsl:when>
            <xsl:when test="rd:conceptType = 'Complex'">
              <insert tableName="concept_complex">
                <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{rd:uuid}' )"/>
                <column name="handler" value="BinaryDataHandler"/>
              </insert>
            </xsl:when>
            <xsl:when test="rd:conceptType = 'Coded' and rd:units/text()">
              <xsl:variable name="questionConcept" select="."/>
              <xsl:variable name="answerConcepts" select="//rd:referenceTerm[contains($questionConcept/rd:units, rd:id)]"/>

              <xsl:for-each select="$answerConcepts">
                <!-- Look for answers -->
                <insert tableName="concept_answer">
                  <column name="answer_concept" valueComputed="(select concept_id from concept where uuid = '{rd:uuid}' )"/>
                  <column name="uuid" valueComputed="uuid()"/>
                  <column name="creator" valueNumeric="1"/>
                  <column name="date_created" valueComputed="now()"/>
                  <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$questionConcept/rd:uuid}' )"/>
                </insert>
              </xsl:for-each>

            </xsl:when>
          </xsl:choose>

        </changeSet>
        <xsl:variable name="mapType">
          <xsl:choose>
            <xsl:when test="rd:units/text() != '' and rd:conceptType = 'Numeric'">NARROWER-THAN</xsl:when>
            <xsl:otherwise>SAME-AS</xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <!-- call map -->
        <xsl:if test="rd:codeSystem/text()">
          <xsl:call-template name="createMap">
            <xsl:with-param name="conceptId" select="rd:uuid"/>
            <xsl:with-param name="mapType" select="$mapType"/>
            <xsl:with-param name="referenceTerm" select="."/>
          </xsl:call-template>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <!-- Concept is mapped to existing concept -->
        <xsl:apply-templates select="rd:mapping"/>
      </xsl:otherwise>
    </xsl:choose>

    <!-- add reference term to sets -->
    <xsl:variable name="member" select="."/>
    <xsl:variable name="memberOfSets" select="//rd:referenceTerm[contains($member/rd:setOf, rd:id)]"/>
    <xsl:variable name="memberUuid">
      <xsl:choose>
        <xsl:when test="not(rd:mapping/rd:concept/rd:cielId/text())">
          <xsl:value-of select="rd:uuid"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="postpend-pad">
            <xsl:with-param name="length" select="'36'"/>
            <xsl:with-param name="padChar" select="'A'"/>
            <xsl:with-param name="padVar" select="rd:mapping/rd:concept/rd:cielId"/>
          </xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:for-each select="$memberOfSets">
      <xsl:sort select="id"/>
      <xsl:variable name="setUuid">
	      <xsl:choose>
	        <xsl:when test="not(rd:mapping/rd:concept/rd:cielId/text())">
	          <xsl:value-of select="rd:uuid"/>
	        </xsl:when>
	        <xsl:otherwise>
	          <xsl:call-template name="postpend-pad">
	            <xsl:with-param name="length" select="'36'"/>
	            <xsl:with-param name="padChar" select="'A'"/>
	            <xsl:with-param name="padVar" select="rd:mapping/rd:concept/rd:cielId"/>
	          </xsl:call-template>
	        </xsl:otherwise>
	      </xsl:choose>
      </xsl:variable>
      <changeSet  dbms="mysql" author="justin" id="shr-cdahandler-{$taskId + position() + 1}" runInTransaction="true">
        <preConditions onError="HALT" onFail="MARK_RAN">
          <and>
            <tableExists tableName="concept_name"/>
            <tableExists tableName="concept"/>
            <tableExists tableName="concept_set"/>
            <!-- Check that the concept exists -->
            <sqlCheck expectedResult="1">
              select count(uuid) from concept where uuid='<xsl:value-of select="$memberUuid"/>'
            </sqlCheck>
            <!-- Check that the set concept exists -->
            <sqlCheck expectedResult="1">
              select count(uuid) from concept where uuid='<xsl:value-of select="$setUuid"/>'
            </sqlCheck>
            <sqlCheck expectedResult="0">
              select count(concept_set_id) from concept_set inner join concept as memberConcept on (concept_set.concept_id = memberConcept.concept_id)
              inner join concept as setmemberConcept on (setmemberConcept.concept_id = concept_set.concept_set)
              where memberConcept.uuid = '<xsl:value-of select="$memberUuid"/>'
              and setmemberConcept.uuid = '<xsl:value-of select="$setUuid"/>'
            </sqlCheck>
          </and>
        </preConditions>
        <comment>
          Adding <xsl:value-of select="$conceptName"/> to set <xsl:value-of select="rd:description"/>
        </comment>
        <insert tableName="concept_set">
          <column name="concept_set_id" autoIncrement="true"/>
          <column name="concept_id" valueComputed="(select concept_id from concept where uuid= '{$memberUuid}')"/>
          <column name="concept_set" valueComputed="(select concept_id from concept where uuid = '{$setUuid}')"/>
          <column name="creator" valueNumeric="1"/>
          <column name="uuid" valueComputed="uuid()"/>
          <column name="date_created" valueComputed="now()"/>
        </insert>

      </changeSet>
    </xsl:for-each>

  </xsl:template>

  <xsl:template match="rd:mapping">

    <!-- There is a distinct possibility the term we're mapping to doesn't exist. This means that our freshly
    created reference term isn't able to be used -->
    <xsl:variable name="referenceTerm" select="parent::rd:referenceTerm" />
    <xsl:variable name="taskId" select="$referenceTerm/rd:id * 100" />
    <xsl:variable name="id" select="$referenceTerm/rd:id"/>
    <xsl:variable name="isSet" select="//rd:setOf[contains(text(),$id)]"/>
    <xsl:variable name="cielUuid">
      <xsl:call-template name="postpend-pad">
        <xsl:with-param name="length" select="'36'"/>
        <xsl:with-param name="padChar" select="'A'"/>
        <xsl:with-param name="padVar" select="rd:concept/rd:cielId"/>
      </xsl:call-template>
    </xsl:variable>

    <changeSet  dbms="mysql" author="justin" id="shr-cdahandler-{$taskId + 1}" runInTransaction="true">
      <preConditions onError="HALT" onFail="MARK_RAN">
        <and>
          <tableExists tableName="concept_name"/>
          <tableExists tableName="concept"/>
          <!-- Create a concept -->
          <sqlCheck expectedResult="0">
            select count(concept_id) from concept where uuid='<xsl:value-of select="$cielUuid"/>'
          </sqlCheck>
          <sqlCheck expectedResult="1">
            select count(concept_datatype_id) from concept_datatype where name='<xsl:value-of select="$referenceTerm/rd:conceptType"/>'
          </sqlCheck>
        </and>
      </preConditions>
      <comment>
        Mapped term to an invalid concept <xsl:value-of select="rd:name"/>
      </comment>
      <insert tableName="concept">
        <column name="concept_id" autoIncrement="true"/>
        <column name="short_name" value="{$referenceTerm/rd:code}"/>
        <column name="description" value="{rd:concept/rd:name}"/>
        <column name="uuid" value="{$cielUuid}"/>
        <column name="datatype_id" valueComputed="(select concept_datatype_id from concept_datatype where name='{$referenceTerm/rd:conceptType}')"/>
        <xsl:choose>
          <!-- SET -->
          <xsl:when test="$isSet">
            <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='ConvSet')"/>
          </xsl:when>
          <xsl:when test="rd:classification/text()">
            <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='{$referenceTerm/rd:classification}')"/>
          </xsl:when>
          <xsl:otherwise>
            <column name="class_id" valueComputed="(select concept_class_id from concept_class where name='Misc')"/>
          </xsl:otherwise>
        </xsl:choose>
        <column name="is_set" valueBoolean="{count($isSet) > 0}"/>
        <column name="creator" valueNumeric="1"/>
        <column name="date_created" valueComputed="now()"/>
      </insert>
      <insert tableName="concept_name">
        <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$cielUuid}')"/>
        <column name="name" value="{rd:concept/rd:name}"/>
        <column name="locale" value="en"/>
        <column name="creator" valueNumeric="1"/>
        <column name="date_created" valueComputed="now()"/>
        <column name="uuid" valueComputed="uuid()"/>
        <column name="concept_name_id" autoIncrement="true"/>
        <column name="concept_name_type" value="FULLY_SPECIFIED"/>
        <column name="locale_preferred" valueBoolean="1"/>
      </insert>
      <xsl:choose>
        <xsl:when test="$referenceTerm/rd:conceptType = 'Numeric'">
          <insert tableName="concept_numeric">
            <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$cielUuid}')"/>
            <column name="units" value="{rd:units}"/>
          </insert>
        </xsl:when>
        <xsl:when test="$referenceTerm/rd:conceptType = 'Complex'">
          <insert tableName="concept_complex">
            <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$cielUuid}')"/>
            <column name="handler" value="BinaryDataHandler"/>
          </insert>
        </xsl:when>
        <xsl:when test="$referenceTerm/rd:conceptType = 'Coded' and $referenceTerm/rd:units/text()">
          <xsl:variable name="questionConcept" select="$referenceTerm"/>
          <xsl:variable name="answerConcepts" select="//rd:referenceTerm[contains($questionConcept/rd:units, rd:id)]"/>

          <xsl:for-each select="$answerConcepts">
            <!-- Look for answers -->
            <xsl:variable name="answerName">
              <xsl:choose>
                <xsl:when test="rd:mapping/rd:concept/rd:name/text()">
                  <xsl:value-of select="rd:mapping/rd:concept/rd:name/text()"/>
                </xsl:when>
                <xsl:when test="rd:conceptType = 'Numeric' and rd:units/text()">
                  <xsl:value-of select="concat(rd:description, ' (', rd:units, ')')"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="rd:description"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <insert tableName="concept_answer">
              <column name="answer_concept" valueComputed="(select concept_id from concept where uuid = '{rd:uuid}')"/>
              <column name="uuid" valueComputed="uuid()"/>
              <column name="creator" valueNumeric="1"/>
              <column name="date_created" valueComputed="now()"/>
              <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$cielUuid}')"/>
            </insert>
          </xsl:for-each>

        </xsl:when>
      </xsl:choose>

    </changeSet>

    <xsl:call-template name="createMap">
      <xsl:with-param name="conceptId" select="$cielUuid"/>
      <xsl:with-param name="mapType" select="rd:concept/rd:mapType"/>
      <xsl:with-param name="referenceTerm" select="$referenceTerm"/>
    </xsl:call-template>
  </xsl:template>

  <!-- Create concept mapping -->
  <xsl:template name="createMap">
    <xsl:param name="conceptId"/>
    <xsl:param name="mapType"/>
    <xsl:param name="referenceTerm"/>

    <changeSet  dbms="mysql" author="justin" id="shr-cdahandler-{$referenceTerm/rd:id * 100 + 99}" runInTransaction="true">
      <preConditions onError="HALT" onFail="MARK_RAN">
        <and>
          <tableExists tableName="concept_name"/>
          <tableExists tableName="concept"/>
          <tableExists tableName="concept_reference_map"/>
          <tableExists tableName="concept_reference_term"/>
          <!-- Check that the concept exists -->
          <sqlCheck expectedResult="1">
            select count(concept_id) from concept where uuid='<xsl:value-of select="$conceptId"/>'
          </sqlCheck>
          <!-- check reference term exists -->
          <sqlCheck expectedResult="1">
            select count(concept_reference_term_id) from concept_reference_term inner join concept_reference_source on (concept_reference_term.concept_source_id = concept_reference_source.concept_source_id)
            where code='<xsl:value-of select="$referenceTerm/rd:code"/>' and concept_reference_source.name = '<xsl:value-of select="$referenceTerm/rd:codeSystemName"/>'
          </sqlCheck>
        </and>
        <!-- ensure map doesn't already exist -->
        <sqlCheck expectedResult="0">
          select count(concept_map_id) from concept_reference_map inner join concept on (concept_reference_map.concept_id = concept.concept_id)
          inner join concept_reference_term on (concept_reference_term.concept_reference_term_id = concept_reference_map.concept_reference_term_id)
          inner join concept_reference_source on (concept_reference_source.concept_source_id = concept_reference_term.concept_source_id)
          where concept_reference_term.code='<xsl:value-of select="$referenceTerm/rd:code"/>'
          and concept_reference_source.name = '<xsl:value-of select="$referenceTerm/rd:codeSystemName"/>'
          and concept.uuid = '<xsl:value-of select="$conceptId"/>'
        </sqlCheck>
      </preConditions>
      <comment>
        Create map :
        Concept: <xsl:value-of select="$referenceTerm/rd:code"/>
        Is: <xsl:value-of select="$mapType"/>
        Term: <xsl:value-of select="$conceptId"/>
      </comment>
      <insert tableName="concept_reference_map">
        <column name="concept_map_id" autoIncrement="true"/>
        <column name="creator" valueNumeric="1"/>
        <column name="date_created" valueComputed="now()"/>
        <column name="uuid" valueComputed="uuid()"/>
        <column name="concept_id" valueComputed="(select concept_id from concept where uuid = '{$conceptId}' )"/>
        <column name="concept_reference_term_id" valueComputed="(select concept_reference_term_id from concept_reference_term inner join concept_reference_source on (concept_reference_source.concept_source_id = concept_reference_term.concept_source_id) where code = '{$referenceTerm/rd:code}' and concept_reference_source.name = '{$referenceTerm/rd:codeSystemName}')"/>
        <column name="concept_map_type_id" valueComputed="(select concept_map_type_id from concept_map_type where name = '{$mapType}')"/>
      </insert>
    </changeSet>
  </xsl:template>

  <xsl:template name="postpend-pad">
    <!-- recursive template to right justify and prepend the value with whatever padChar is passed in   -->
    <xsl:param name="padChar"> </xsl:param>
    <xsl:param name="padVar"/>
    <xsl:param name="length"/>
    <xsl:choose>
      <xsl:when test="string-length($padVar) &lt; $length">
        <xsl:call-template name="postpend-pad">
          <xsl:with-param name="padChar" select="$padChar"/>
          <xsl:with-param name="padVar" select="concat($padVar,$padChar)"/>
          <xsl:with-param name="length" select="$length"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="substring($padVar,string-length($padVar) - $length + 1)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
</xsl:stylesheet>
